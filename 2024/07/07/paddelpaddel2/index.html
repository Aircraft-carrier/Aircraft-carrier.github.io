
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>paddelpaddel 2 | Aircraft</title>
    <meta name="author" content="Aircraft" />
    <meta name="description" content="谁替我上学 我可以替你睡觉" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.0.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>AIRCRAFT</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;AIRCRAFT</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>paddelpaddel 2</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/7
        </span>
        
        <span class="category">
            <a href="/categories/Learning/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Learning
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/PaddlePaddle/" style="color: #03a9f4">
                    PaddlePaddle
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/deep-learning/" style="color: #00bcd4">
                    deep learning
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/AI/" style="color: #00a596">
                    AI
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="paddelpaddel"><a href="#paddelpaddel" class="headerlink" title="paddelpaddel"></a>paddelpaddel</h1><h2 id="模型训练、评估与推理"><a href="#模型训练、评估与推理" class="headerlink" title="模型训练、评估与推理"></a>模型训练、评估与推理</h2><h3 id="1、训练前准备"><a href="#1、训练前准备" class="headerlink" title="1、训练前准备"></a>1、训练前准备</h3><h4 id="1-1-指定训练的硬件"><a href="#1-1-指定训练的硬件" class="headerlink" title="1.1 指定训练的硬件"></a>1.1 指定训练的硬件</h4><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=模型训练&amp;spm=1001.2101.3001.7020">模型训练</a>时，需要用到 CPU、 GPU 等计算处理器资源，由于飞桨框架的安装包是区分处理器类型的，默认情况下飞桨框架会根据所安装的版本自动选择对应硬件，比如安装的 GPU 版本的飞桨，则自动使用 GPU 训练模型，无需手动指定。因此一般情况下，无需执行此步骤。</p>
<p>但是如果安装的 GPU 版本的飞桨框架，想切换到 CPU 上训练，则可通过 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/device/set_device_cn.html#set-device">paddle.device.set_device</a> 修改。如果本机有多个 GPU 卡，也可以通过该 API 选择指定的卡进行训练，不指定的情况下则默认使用 ‘gpu:0’。</p>
<pre><code class="lang-python">import paddle
# 指定在 CPU 上训练
paddle.device.set_device(&#39;cpu&#39;)
# 指定在 GPU 第 0 号卡上训练
paddle.device.set_device(&#39;gpu:0&#39;)
</code></pre>
<h4 id="1-2-准备训练用的数据集和模型"><a href="#1-2-准备训练用的数据集和模型" class="headerlink" title="1.2 准备训练用的数据集和模型"></a>1.2 准备训练用的数据集和模型</h4><p>模型训练前，需要先完成数据集的加载和模型组网，以 MNIST 手写数字识别任务为例，代码示例如下：</p>
<pre><code class="lang-python">from paddle.vision.transforms import Normalize
transform = Normalize(mean=[127.5], std=[127.5], data_format=&#39;CHW&#39;)

# 加载 MNIST 训练集和测试集
train_dataset = paddle.vision.datasets.MNIST(mode=&#39;train&#39;, transform=transform)
test_dataset = paddle.vision.datasets.MNIST(mode=&#39;test&#39;, transform=transform)

# 模型组网，构建并初始化一个模型 mnist
mnist = paddle.nn.Sequential(
    paddle.nn.Flatten(1, -1), 
    paddle.nn.Linear(784, 512), 
    paddle.nn.ReLU(), 
    paddle.nn.Dropout(0.2), 
    paddle.nn.Linear(512, 10)
)
</code></pre>
<h3 id="2、使用-paddle-Model-高层-API-训练、评估与推理"><a href="#2、使用-paddle-Model-高层-API-训练、评估与推理" class="headerlink" title="2、使用 paddle.Model 高层 API 训练、评估与推理"></a>2、使用 paddle.Model 高层 API 训练、评估与推理</h3><h4 id="2-1-使用-paddle-Model-封装模型"><a href="#2-1-使用-paddle-Model-封装模型" class="headerlink" title="2.1 使用 paddle.Model 封装模型"></a>2.1 使用 paddle.Model 封装模型</h4><pre><code class="lang-python"># 封装模型为一个 model 实例，便于进行后续的训练、评估和推理
model = paddle.Model(mnist)
</code></pre>
<h4 id="2-2-使用-Model-prepare-配置训练准备参数"><a href="#2-2-使用-Model-prepare-配置训练准备参数" class="headerlink" title="2.2 使用 Model.prepare 配置训练准备参数"></a>2.2 使用 Model.prepare 配置训练准备参数</h4><p>用 <code>paddle.Model</code> 完成模型的封装后，需通过 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/Model_cn.html#prepare-optimizer-none-loss-none-metrics-none-amp-configs-none">Model.prepare</a> 进行训练前的配置准备工作，包括设置优化算法、Loss 计算方法、评价指标计算方法：</p>
<ul>
<li><strong>优化器（optimizer）</strong>：即寻找最优解的方法，可计算和更新梯度，并根据梯度更新模型参数。飞桨框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/optimizer/Overview_cn.html#paddle-optimizer">paddle.optimizer</a> 下提供了优化器相关 API。并且需要为优化器设置合适的学习率，或者指定合适的学习率策略，飞桨框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/optimizer/Overview_cn.html#about-lr">paddle.optimizer.lr</a> 下提供了学习率策略相关的 API。</li>
<li><strong>损失函数（loss）</strong>：用于评估模型的预测值和真实值的差距，模型训练过程即取得尽可能小的 loss 的过程。飞桨框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Overview_cn.html#loss">paddle.nn Loss层</a> 提供了适用不同深度学习任务的损失函数相关 API。</li>
<li><strong>评价指标（metrics）</strong>：用于评估模型的好坏，不同的任务通常有不同的评价指标。飞桨框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/metric/Overview_cn.html">paddle.metric</a> 下提供了评价指标相关 API。</li>
</ul>
<pre><code class="lang-python"># 为模型训练做准备，设置优化器及其学习率，并将网络的参数传入优化器，设置损失函数和精度计算方式
model.prepare(optimizer = paddle.optimizer.Adam(learning_rate = 0.001,parameters = model.parameters()), 
              loss = paddle.nn.CrossEntropyLoss(), 
              metrics = paddle.metric.Accuracy())
</code></pre>
<h4 id="2-3-使用-Model-fit-训练模型"><a href="#2-3-使用-Model-fit-训练模型" class="headerlink" title="2.3 使用 Model.fit 训练模型"></a>2.3 使用 Model.fit 训练模型</h4><ul>
<li><strong>训练数据集</strong>：传入之前定义好的训练数据集。</li>
<li><strong>训练轮次（epoch）</strong>：训练时遍历数据集的次数，即外循环轮次。</li>
<li><strong>批次大小（batch_size）</strong>：内循环中每个批次的训练样本数。</li>
</ul>
<pre><code class="lang-python"># 启动模型训练，指定训练数据集，设置训练轮次，设置每次数据集计算的批次大小，设置日志格式
model.fit(train_dataset, 
          epochs=5, 
          batch_size=64,
          verbose=1)
</code></pre>
<h4 id="2-4-使用-Model-evaluate-评估模型"><a href="#2-4-使用-Model-evaluate-评估模型" class="headerlink" title="2.4 使用 Model.evaluate 评估模型"></a>2.4 使用 Model.evaluate 评估模型</h4><p>使用 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/Model_cn.html#evaluate-eval-data-batch-size-1-log-freq-10-verbose-2-num-workers-0-callbacks-none-num-iters-none">Model.evaluate</a> 接口完成模型评估操作，结束后根据在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/Model_cn.html#prepare-optimizer-none-loss-none-metrics-none-amp-configs-none">Model.prepare</a> 中定义的 <code>loss</code> 和 <code>metric</code> 计算并返回相关评估结果。</p>
<p>返回格式是一个字典:</p>
<ul>
<li>只包含loss， <code>&#123;&#39;loss&#39;: xxx&#125;</code></li>
<li>包含loss和一个评估指标， <code>&#123;&#39;loss&#39;: xxx, &#39;metric name&#39;: xxx&#125;</code></li>
<li>包含loss和多个评估指标， <code>&#123;&#39;loss&#39;: xxx, &#39;metric name1&#39;: xxx, &#39;metric name2&#39;: xxx&#125;</code></li>
</ul>
<pre><code class="lang-python"># 用 evaluate 在测试集上对模型进行验证
eval_result = model.evaluate(test_dataset, verbose=1)
print(eval_result)
</code></pre>
<h4 id="2-5-使用-Model-predict-执行推理"><a href="#2-5-使用-Model-predict-执行推理" class="headerlink" title="2.5 使用 Model.predict 执行推理"></a>2.5 使用 Model.predict 执行推理</h4><p>只需传入待执行推理验证的样本数据，即可计算并返回推理结果。</p>
<p>返回格式是一个列表：</p>
<ul>
<li>模型是单一输出：<code>[(numpy_ndarray_1, numpy_ndarray_2, …, numpy_ndarray_n)]</code></li>
<li>模型是多输出：<code>[(numpy_ndarray_1, numpy_ndarray_2, …, numpy_ndarray_n), (numpy_ndarray_1, numpy_ndarray_2, …, numpy_ndarray_n), …]</code></li>
</ul>
<pre><code class="lang-python"># 用 predict 在测试集上对模型进行推理
test_result = model.predict(test_dataset)
print(test_result[0][0])
# 打印推理结果，这里的argmax函数用于取出预测值中概率最高的一个的下标，作为预测标签
pred_label = test_result[0][0].argmax()
print(&#39;true label: &#123;&#125;, pred label: &#123;&#125;&#39;.format(label[0], pred_label))
</code></pre>
<pre><code class="lang-bash">[[ -6.512169   -6.7076845   0.5048795   1.6733919  -9.670526   -1.6352568
  -15.833721   13.87411    -8.215239    1.5966017]]

true label: 7, pred label: 7
</code></pre>
<p>经过模型的计算得到一个数组：</p>
<p> [[ -6.5593615 -6.4680595 -1.4708003 2.1043894 -11.743436 -4.4516582 -14.733968 12.036645 -6.582403 -1.8672216]]</p>
<p>取其中最大的值（12.036645）的下标（对应 label 7），即得到该样本数据的预测结果（pred label: 7），可视化该样本图像（true label: 7），与预测结果一致，说明模型准确预测了样本图像上的数字。 </p>
<h3 id="3、使用基础-API-训练、评估与推理"><a href="#3、使用基础-API-训练、评估与推理" class="headerlink" title="3、使用基础 API 训练、评估与推理"></a>3、使用基础 API 训练、评估与推理</h3><h4 id="3-1-模型训练（拆解-Model-prepare、Model-fit）"><a href="#3-1-模型训练（拆解-Model-prepare、Model-fit）" class="headerlink" title="3.1 模型训练（拆解 Model.prepare、Model.fit）"></a>3.1 模型训练（拆解 Model.prepare、Model.fit）</h4><p>飞桨框架通过基础 API 对模型进行训练，对应高层 API 的 <code>Model.prepare</code> 与 <code>Model.fit</code> ，一般包括如下几个步骤：</p>
<pre><code class="lang-python">import paddle
import paddle.nn as nn
import paddle.optimizer as optim
from paddle.vision.datasets import DatasetFolder
from paddle.io import DataLoader

# 1. Load training dataset, declare model, and set model instance to `train` mode
class MyDataset(DatasetFolder):
    def __init__(self, data_path, transform=None):
        super(MyDataset, self).__init__(data_path, transform=transform)

dataset = MyDataset(&#39;path/to/dataset&#39;, transform=None)
data_loader = DataLoader(dataset, batch_size=32, shuffle=True)

class MyModel(nn.Layer):
    def __init__(self):
        super(MyModel, self).__init__()
        # define model architecture here

model = MyModel()
model.train()

# 2. Set optimizer, loss function, and hyperparameters
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), learning_rate=0.001)

# 3. Set up two-layer nested loop for training
for epoch in range(10):  # outer loop for epochs
    for batch in data_loader:  # inner loop for batches
        # 3.1 Get a batch of training data from DataLoader
        inputs, labels = batch

        # 3.2 Execute a forward pass to get predicted values
        outputs = model(inputs)

        # 3.3 Calculate loss between predicted values and labels
        loss = criterion(outputs, labels)

        # 3.4 Calculate accuracy between predicted values and labels
        accuracy = paddle.metric.accuracy(outputs, labels)

        # 3.5 Backward pass to compute gradients
        loss.backward()

        # 3.6 Print model&#39;s epoch, batch, loss, and accuracy
        print(f&#39;Epoch: &#123;epoch&#125;, Batch: &#123;batch&#125;, Loss: &#123;loss.item():.4f&#125;, Accuracy: &#123;accuracy.item():.4f&#125;&#39;)

        # 3.7 Update model parameters using optimizer
        optimizer.step()

        # 3.8 Clear gradients for next batch
        optimizer.clear_grad()
</code></pre>
<h4 id="3-2-模型评估（拆解-Model-evaluate）"><a href="#3-2-模型评估（拆解-Model-evaluate）" class="headerlink" title="3.2 模型评估（拆解 Model.evaluate）"></a>3.2 模型评估（拆解 Model.evaluate）</h4><p>飞桨框架通过基础 API 对训练好的模型进行评估，对应高层 API 的 <code>Model.evaluate</code> 。与模型训练相比，模型评估的流程有如下几点不同之处：</p>
<ol>
<li>加载的数据从训练数据集改为测试数据集</li>
<li>模型实例从 <code>train</code> 模式改为 <strong><code>eval</code> 模式</strong></li>
<li>不需要反向传播、优化器参数更新和优化器梯度清零</li>
</ol>
<pre><code class="lang-python"># 加载测试数据集
test_loader = paddle.io.DataLoader(test_dataset, batch_size=64, drop_last=True)
# 设置损失函数
loss_fn = paddle.nn.CrossEntropyLoss()
# 将该模型及其所有子层设置为预测模式。这只会影响某些模块，如Dropout和BatchNorm
mnist.eval()
# 禁用动态图梯度计算
for batch_id, data in enumerate(test_loader()):
    x_data = data[0]            # 测试数据
    y_data = data[1]            # 测试数据标签
    predicts = mnist(x_data)    # 预测结果

    # 计算损失与精度
    loss = loss_fn(predicts, y_data)
    acc = paddle.metric.accuracy(predicts, y_data)

    # 打印信息
    if (batch_id+1) % 30 == 0:
        print(&quot;batch_id: &#123;&#125;, loss is: &#123;&#125;, acc is: &#123;&#125;&quot;.format(batch_id+1, loss.numpy(), acc.numpy()))
</code></pre>
<h4 id="3-3-模型推理（拆解-Model-predict）"><a href="#3-3-模型推理（拆解-Model-predict）" class="headerlink" title="3.3 模型推理（拆解 Model.predict）"></a>3.3 模型推理（拆解 Model.predict）</h4><p>飞桨框架通过基础 API 对训练好的模型执行推理，对应高层 API 的 <code>Model.predict</code> 。模型的推理过程相对独立，是在模型训练与评估之后单独进行的步骤。只需要执行如下步骤：</p>
<ol>
<li>加载待执行推理的测试数据，并将模型设置为 <strong><code>eval</code> 模式</strong></li>
<li>读取测试数据并获得预测结果</li>
<li>对预测结果进行后处理</li>
</ol>
<pre><code class="lang-python"># 加载测试数据集
test_loader = paddle.io.DataLoader(test_dataset, batch_size=64, drop_last=True)
# 将该模型及其所有子层设置为预测模式
mnist.eval()
for batch_id, data in enumerate(test_loader()):
    # 取出测试数据
    x_data = data[0] 
    # 获取预测结果
    predicts = mnist(x_data)
print(&quot;predict finished&quot;)

# 从测试集中取出一组数据
img, label = test_loader().next()

# 执行推理并打印结果
pred_label = mnist(img)[0].argmax()

print(&#39;true label: &#123;&#125;, pred label: &#123;&#125;&#39;.format(label[0].item(), pred_label[0].item()))

# 可视化图片
from matplotlib import pyplot as plt
plt.imshow(img[0][0])
</code></pre>
<h2 id="模型保存练与加载"><a href="#模型保存练与加载" class="headerlink" title="模型保存练与加载"></a>模型保存练与加载</h2><h3 id="1、训练调优场景"><a href="#1、训练调优场景" class="headerlink" title="1、训练调优场景"></a>1、训练调优场景</h3><h4 id="1-1-使用基础API"><a href="#1-1-使用基础API" class="headerlink" title="1.1 使用基础API"></a>1.1 使用基础API</h4><ul>
<li><a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/save_cn.html">paddle.save</a>：使用 <code>paddle.save</code>保存模型，实际是通过 Python pickle 模块来实现的，传入要保存的数据对象后，会在指定路径下生成一个 pickle 格式的磁盘文件。</li>
<li><a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/load_cn.html">paddle.load</a>：加载时还需要之前的模型组网代码，并使用<code>paddle.load</code>传入保存的文件路径，即可重新将之前保存的数据从磁盘文件中载入。</li>
</ul>
<p>另外，<code>paddle.save</code>还支持直接保存 Tensor 数据，或者含 Tensor 的 list/dict 嵌套结构。所以动态图模式下，可支持保存和加载的内容包括：</p>
<ul>
<li><strong>网络层参数</strong>： <code>Layer.state_dict()</code></li>
<li><strong>优化器参数</strong>： <code>Optimizer.state_dict()</code></li>
<li><strong>Tensor 数据</strong> ：（如创建的 Tensor 数据、网络层的 weight 数据等）</li>
<li><strong>含 Tensor 的 list/dict 嵌套结构对象</strong> （如保存 state_dict() 的嵌套结构对象：<code>obj = &#123;&#39;model&#39;: layer.state_dict(), &#39;opt&#39;: adam.state_dict(), &#39;epoch&#39;: 100&#125;</code>）</li>
</ul>
<h5 id="保存动态图模型"><a href="#保存动态图模型" class="headerlink" title="保存动态图模型"></a>保存动态图模型</h5><pre><code class="lang-python"># 保存Layer参数
paddle.save(layer.state_dict(), &quot;linear_net.pdparams&quot;)
# 保存优化器参数
paddle.save(adam.state_dict(), &quot;adam.pdopt&quot;)
# 保存检查点checkpoint信息
paddle.save(final_checkpoint, &quot;final_checkpoint.pkl&quot;)
</code></pre>
<blockquote>
<ol>
<li>对于 <code>Layer.state_dict()</code> （模型参数），推荐使用后缀 <code>.pdparams</code> ；</li>
<li>对于 <code>Optimizer.state_dict()</code> （优化器参数），推荐使用后缀 <code>.pdopt</code> 。</li>
</ol>
</blockquote>
<h5 id="加载动态图模型"><a href="#加载动态图模型" class="headerlink" title="加载动态图模型"></a>加载动态图模型</h5><pre><code class="lang-python"># 载入模型参数、优化器参数和最后一个epoch保存的检查点
layer_state_dict = paddle.load(&quot;linear_net.pdparams&quot;)
opt_state_dict = paddle.load(&quot;adam.pdopt&quot;)
final_checkpoint_dict = paddle.load(&quot;final_checkpoint.pkl&quot;)

# 将load后的参数与模型关联起来
layer.set_state_dict(layer_state_dict)
adam.set_state_dict(opt_state_dict)

# 打印出来之前保存的 checkpoint 信息
print(&quot;Loaded Final Checkpoint. Epoch : &#123;&#125;, Loss : &#123;&#125;&quot;.format(final_checkpoint_dict[&quot;epoch&quot;], final_checkpoint_dict[&quot;loss&quot;].numpy()))
</code></pre>
<p>加载以后就可以继续对动态图模型进行训练调优（fine-tune），或者验证预测效果（predict）。</p>
<h4 id="1-2-使用高层API"><a href="#1-2-使用高层API" class="headerlink" title="1.2 使用高层API"></a>1.2 使用高层API</h4><h5 id="保存动态图模型-1"><a href="#保存动态图模型-1" class="headerlink" title="保存动态图模型"></a>保存动态图模型</h5><ul>
<li>方式一：开启训练时调用的<code>paddle.Model.fit</code>函数可自动保存模型，通过它的参数 <code>save_freq</code>可以设置保存动态图模型的频率，即多少个 epoch 保存一次模型，默认值是 1。</li>
<li>方式二：调用 <code>paddle.Model.save</code>API。只需要传入保存的模型文件的前缀，格式如 <code>dirname/file_prefix</code> 或者 <code>file_prefix</code> ，即可保存训练后的模型参数和优化器参数，保存后的文件后缀名固定为 <code>.pdparams</code> 和<code>.pdopt</code>。</li>
</ul>
<pre><code class="lang-python">#方式一：设置训练过程中保存模型
model.fit(data, epochs=1, batch_size=32, save_freq=1)

#方式二：设置训练后保存模型
model.save(&#39;checkpoint/test&#39;)  # save for training
</code></pre>
<h5 id="加载动态图模型-1"><a href="#加载动态图模型-1" class="headerlink" title="加载动态图模型"></a>加载动态图模型</h5><p>高层 API 加载动态图模型所需要调用的 API 是 <code>paddle.Model.load</code>，从指定的文件中载入模型参数和优化器参数（可选）以继续训练。<code>paddle.Model.load</code>需要传入的核心的参数是待加载的模型参数或者优化器参数文件（可选）的前缀（需要保证后缀符合 <code>.pdparams</code> 和<code>.pdopt</code>）。</p>
<pre><code class="lang-python"># 加载模型参数和优化器参数
model.load(&#39;checkpoint/test&#39;)
model.fit(data, epochs=1, batch_size=32, save_freq=1)
model.save(&#39;checkpoint/test_1&#39;)  # save for training
</code></pre>
<h3 id="2、-推理部署场景"><a href="#2、-推理部署场景" class="headerlink" title="2、 推理部署场景"></a>2、 推理部署场景</h3><h4 id="2-1-使用基础API"><a href="#2-1-使用基础API" class="headerlink" title="2.1 使用基础API"></a>2.1 使用基础API</h4><ul>
<li><code>paddle.jit.save</code> 保存模型</li>
<li><code>paddle.jit.load</code> 加载模型</li>
</ul>
<p>使用 <code>paddle.jit.save</code> 保存模型，通常是在后台执行了两个步骤：</p>
<ol>
<li>先执行了动转静。当然如果前面已经执行了动转静训练，则跳过这一步。在处理逻辑上，主要包含两个主要模块：<ul>
<li>模型结构层面：将动态图模型中被 <code>@paddle.jit.to_static</code> 装饰的函数转化为完整的静态图 Program。</li>
<li>模型参数层面：将动态图模型中的参数（Parameters 和 Buffers ）转为 <code>Persistable=True</code> 的静态图模型参数 Variable。</li>
</ul>
</li>
<li>再将静态图模型和参数导出为磁盘文件。Program 和 Variable 都可以直接序列化导出为磁盘文件，与前端代码完全解耦，导出的文件包括：<ul>
<li>后缀为 <code>.pdmodel</code> 的模型结构文件；</li>
<li>后缀为 <code>.pdiparams</code> 的模型参数文件；</li>
<li>后缀为 <code>.pdiparams.info</code> 的和参数状态有关的额外信息文件。</li>
</ul>
</li>
</ol>
<h5 id="动转静"><a href="#动转静" class="headerlink" title="动转静"></a>动转静</h5><p> 方式一：使用 <code>@paddle.jit.to_static</code> 装饰器</p>
<pre><code class="lang-python">class LinearNet(nn.Layer):
    def __init__(self):
        super().__init__()
        self._linear = nn.Linear(IMAGE_SIZE, CLASS_NUM)

    @paddle.jit.to_static       # &lt;----在前向计算 forward 函数前添加一个装饰器
    def forward(self, x):
        return self._linear(x)
</code></pre>
<p> 方式二：使用 <code>@paddle.jit.to_static</code> 函数</p>
<pre><code class="lang-python"># create network
layer = LinearNet()
layer = paddle.jit.to_static(layer) # &lt;----通过函数式调用 paddle.jit.to_static(layer) 一键实现动转静
</code></pre>
<p>动转静训练完成后，使用 <code>paddle.jit.save</code> 对模型和参数进行存储：</p>
<pre><code class="lang-python"># 如果保存模型用于推理部署，则需切换 eval()模式
layer.eval()
# 使用 paddle.jit.save 保存训练好的静态图模型
path = &quot;example.model/linear&quot;
paddle.jit.save(layer, path)
</code></pre>
<h5 id="模型加载样例"><a href="#模型加载样例" class="headerlink" title="模型加载样例"></a>模型加载样例</h5><p>动转静训练保存模型后，如果需要再加载用于训练调优或验证推理效果，可以选择使用 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api/paddle/jit/load_cn.html#load">paddle.jit.load</a> 或 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/develop/api/paddle/load_cn.html#load">paddle.load</a> API。</p>
<ul>
<li><strong>使用 <code>paddle.jit.load</code> 加载</strong>：该方式可以载入模型结构和参数，传入数据即可训练或推理。</li>
<li><strong>使用 <code>paddle.load</code> 加载</strong>：如果已有组网代码，则只传入模型参数也可再训练，因此也可以选择该方式加载。</li>
</ul>
<pre><code class="lang-python"># 载入 paddle.jit.save 保存的模型
path = &quot;example.model/linear&quot;
loaded_layer = paddle.jit.load(path)
# 执行预测
loaded_layer.eval()
x = paddle.randn([1, IMAGE_SIZE], &#39;float32&#39;)
pred = loaded_layer(x)
</code></pre>
<h4 id="2-2-使用高层API"><a href="#2-2-使用高层API" class="headerlink" title="2.2 使用高层API"></a>2.2 使用高层API</h4><p><code>paddle.Model.save</code>的第一个参数需要设置为待保存的模型和参数等文件的前缀名，第二个参数 <code>training</code> 表示是否保存动态图模型以继续训练，默认是 True，这里需要设为 False，即保存推理部署所需的参数与文件。接前文高层 API 训练的示例代码，保存推理模型代码示例如下：</p>
<pre><code class="lang-python">model.save(&#39;inference_model&#39;, False)  # save for inference
</code></pre>
<p>其他同训练调优场景</p>
<pre><code class="lang-python"># 加载模型参数和优化器参数
model.load(&#39;checkpoint/test&#39;)
test_result = model.predict(test_dataset)
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Aircraft
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Aircraft
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="Aircraft-carrier/git-discussions-"
    data-repo-id="R_kgDOMSMEYQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOMSMEYc4CglYu"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light_tritanopia"
    data-lang="zh-CN"
    crossorigin
    async
></script>









    

    <canvas
        id="fireworks"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
    ></canvas>
    <script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="/js/fireworks.min.js"></script>  

    <canvas
        id="background"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
    ></canvas>
    <script src="/js/background.min.js"></script>

    <div id="cursor"></div>
    <link rel="stylesheet" href="/css/cursor.min.css" />
    <script src="/js/cursor.min.js"></script>

</body>
</html>
