
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>PaddlePaddle 1 | Aircraft</title>
    <meta name="author" content="Aircraft" />
    <meta name="description" content="谁替我上学 我可以替你睡觉" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>



<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 6.0.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>AIRCRAFT</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;AIRCRAFT</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>PaddlePaddle 1</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/7/7
        </span>
        
        <span class="category">
            <a href="/categories/Learning/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Learning
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/PaddlePaddle/" style="color: #ffa2c4">
                    PaddlePaddle
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/deep-learning/" style="color: #00bcd4">
                    deep learning
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/AI/" style="color: #03a9f4">
                    AI
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="PaddlePaddle"><a href="#PaddlePaddle" class="headerlink" title="PaddlePaddle"></a>PaddlePaddle</h1><h2 id="paddle安装"><a href="#paddle安装" class="headerlink" title="paddle安装"></a>paddle安装</h2><ul>
<li>从官方获取安装命令</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/">飞桨PaddlePaddle-源于产业实践的开源深度学习平台</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Aircraft-carrier/PicGOO/images/18adf5d045f207ee30c14eac7cfc2a4.png"/></p>
<p>根据自己的芯片型号获得适当的安装命令。可以采用<code>nvidia-smi</code>来查看</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63034152/article/details/131183819?spm=1001.2014.3001.5501">cuda 安装教程</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/Aircraft-carrier/PicGOO/images/1d3a397c059d84f637772d2e10564b2.png"/></p>
<ul>
<li>创建conda环境</li>
</ul>
<pre><code class="lang-bash">conda create -n paddle_env python=YOUR_PY_VER
activate paddle_env
</code></pre>
<p>对于国内用户无法连接到 Anaconda 官方源的可以按照以下命令添加清华源:</p>
<pre><code class="lang-bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
</code></pre>
<pre><code class="lang-bash">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
</code></pre>
<pre><code class="lang-bash">conda config --set show_channel_urls yes
</code></pre>
<h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><h3 id="1、Tensor的创建"><a href="#1、Tensor的创建" class="headerlink" title="1、Tensor的创建"></a>1、Tensor的创建</h3><p>可使用 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/api/paddle/to_tensor_cn.html">paddle.to_tensor</a> 创建任意维度的 Tensor</p>
<p>当创建张量时，您可以根据不同的需求和情况使用以下几种方法：</p>
<ol>
<li>创建指定数据的张量：</li>
</ol>
<ul>
<li>使用Python列表创建张量:</li>
</ul>
<pre><code class="lang-python">import paddle

data = [1, 2, 3, 4, 5]
tensor_data = paddle.to_tensor(data)
print(tensor_data)
</code></pre>
<ul>
<li>使用浮点数数组创建张量：</li>
</ul>
<pre><code class="lang-python">import numpy as np
import paddle

data_float = np.array([1.0, 2.0, 3.0, 4.0, 5.0])
tensor_data_float = paddle.to_tensor(data_float)
print(tensor_data_float)
</code></pre>
<ol>
<li>创建指定形状的张量：</li>
</ol>
<ul>
<li>创建全零张量：</li>
</ul>
<pre><code class="lang-python">shape = [2, 3]  # 2行3列的张量
tensor_zeros = paddle.zeros(shape)
print(tensor_zeros)
</code></pre>
<ul>
<li>创建全一张量：</li>
</ul>
<pre><code class="lang-python">shape = [3, 2]  # 3行2列的张量
tensor_ones = paddle.ones(shape)
print(tensor_ones)
</code></pre>
<ol>
<li>创建指定区间的张量：</li>
</ol>
<ul>
<li>创建指定区间和步长的张量：</li>
</ul>
<pre><code class="lang-python">tensor_range = paddle.arange(start = 1, end = 10, step = 2)
print(tensor_range)
</code></pre>
<ul>
<li>创建均匀间隔的张量：</li>
</ul>
<pre><code class="lang-python">tensor_linspace = paddle.linspace(start = 1, stop = 5, num = 5)
print(tensor_linspace)
</code></pre>
<ol>
<li>创建指定对象的张量：</li>
</ol>
<ul>
<li>从NumPy数组创建张量：</li>
</ul>
<pre><code class="lang-python">numpy_array = np.array([1, 2, 3])
tensor_from_numpy = paddle.to_tensor(numpy_array)
print(tensor_from_numpy)
</code></pre>
<ul>
<li>从Python列表创建张量：</li>
</ul>
<pre><code class="lang-python">import paddle

data_list = [3, 6, 9, 12]
tensor_from_list = paddle.to_tensor(data_list)
print(tensor_from_list)
</code></pre>
<h3 id="2、Tensor-的属性"><a href="#2、Tensor-的属性" class="headerlink" title="2、Tensor 的属性"></a>2、Tensor 的属性</h3><p>在PaddlePaddle中，Tensor具有以下属性：</p>
<ol>
<li>形状（shape）:</li>
</ol>
<ul>
<li><code>shape</code>: 描述了Tensor在每个维度上的元素数量。</li>
<li><code>ndim</code>: Tensor的维度数量，如向量的维度为1，矩阵的维度为2，Tensor可以有任意数量的维度。</li>
<li><code>axis</code>或者<code>dimension</code>: Tensor的轴，即某个特定的维度。</li>
<li><code>size</code>: Tensor中所有元素的个数。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码:"></a>示例代码:</h4><pre><code class="lang-python">import paddle

ndim_4_Tensor = paddle.ones([2, 3, 4, 5])

print(&quot;每个元素的数据类型:&quot;, ndim_4_Tensor.dtype)
print(&quot;维度数量:&quot;, ndim_4_Tensor.ndim)
print(&quot;Tensor的形状:&quot;, ndim_4_Tensor.shape)
print(&quot;第0个维度上的元素数量:&quot;, ndim_4_Tensor.shape[0])
print(&quot;最后一个维度上的元素数量:&quot;, ndim_4_Tensor.shape[-1])
</code></pre>
<ol>
<li>重置 Tensor 形状（Reshape）:</li>
</ol>
<ul>
<li>改变Tensor的形状可以使用<code>paddle.reshape</code>。</li>
<li>在指定新的形状时可以使用<code>-1</code>或者<code>0</code>的技巧。</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码:"></a>示例代码:</h4><pre><code class="lang-python">x = paddle.to_tensor([1, 2, 3])
y = paddle.reshape(x, [1, 3])
</code></pre>
<ol>
<li>数据类型（dtype）:</li>
</ol>
<ul>
<li>Tensor的数据类型dtype可以是<code>bool</code>、<code>float16</code>、<code>float32</code>、<code>float64</code>等。</li>
<li>所有元素的数据类型在同一个Tensor中是相同的。</li>
</ul>
<ol>
<li>设备位置（place）:</li>
</ol>
<ul>
<li>可以指定Tensor位于CPU、GPU或者固定内存上。</li>
<li>可以通过<code>paddle.CPUPlace()</code>、<code>paddle.CUDAPlace(0)</code>和<code>paddle.CUDAPinnedPlace()</code>创建相应位置的Tensor。</li>
</ul>
<pre><code class="lang-python">cpu_tensor = paddle.to_tensor([1, 2, 3], place=paddle.CPUPlace())
gpu_tensor = paddle.to_tensor([1, 2, 3], place=paddle.CUDAPlace(0))
pin_memory_tensor = paddle.to_tensor([1, 2, 3], place=paddle.CUDAPinnedPlace())
</code></pre>
<ol>
<li>名称（name）:</li>
</ol>
<ul>
<li>Tensor还有一个名称属性<code>name</code>，用于标识该Tensor。</li>
</ul>
<pre><code class="lang-python">tensor_name = paddle.to_tensor([1, 2, 3], name=&quot;my_tensor&quot;).name
</code></pre>
<h3 id="3、Tensor-的操作"><a href="#3、Tensor-的操作" class="headerlink" title="3、Tensor 的操作"></a>3、Tensor 的操作</h3><p>在飞桨（PaddlePaddle）中，您可以通过索引和切片来访问或修改Tensor，以下是关于Tensor操作的详细介绍：</p>
<ol>
<li>索引和切片</li>
</ol>
<p>通过索引或切片方式可以访问或修改Tensor。在飞桨中，遵循标准的Python索引规则与Numpy索引规则。</p>
<ul>
<li>索引从0开始，如果下标为负数，则从尾部开始计算。</li>
<li>利用冒号<code>:</code>分隔切片参数，<code>start:stop:step</code>来进行切片操作，其中start、stop、step均可缺省。</li>
</ul>
<pre><code class="lang-python">print(x[:, 1:])
</code></pre>
<ol>
<li>赋值与修改</li>
</ol>
<p>请小心使用索引或切片修改Tensor，在原地修改该Tensor的数值，原值不会被保存。若修改后的Tensor参与梯度计算，仅会使用修改后的数值。</p>
<pre><code class="lang-python">x[1, 0] = 5
</code></pre>
<ol>
<li>Tensor广播</li>
</ol>
<p>飞桨中Tensor的广播机制遵循Numpy的广播规则：</p>
<ul>
<li>每个Tensor至少为一维Tensor。</li>
<li>从最后一个维度向前比较两个Tensor的形状，满足以下条件可以进行广播：两个Tensor的维度大小相等、其中一个Tensor的维度等于1、其中一个Tensor的维度不存在。</li>
</ul>
<pre><code class="lang-python">import paddle

# 创建形状为(1, 2)和(2, 2)的两个Tensor
x = paddle.to_tensor([[1, 2]])
y = paddle.to_tensor([[3, 4], [5, 6]])

# 进行广播操作
result = x + y
print(result)  # 输出: Tensor(shape=[2, 2], dtype=int32, place=CUDAPlace(0), stop_gradient=True, value=[[4, 6], [6, 8]])
</code></pre>
<ol>
<li>Tensor运算</li>
</ol>
<p>飞桨中的Tensor支持多种逐元素运算，如绝对值、取整、指数运算、求倒数、平方、正弦、余弦、相加、相减、相乘、相除等操作。此外，还可以判断元素是否有限、元素是否相等、元素大小关系等。</p>
<pre><code class="lang-python">import paddle

# 创建形状为(2, 2)的Tensor
x = paddle.full(shape=[2, 2], fill_value=2)
y = paddle.full(shape=[2, 2], fill_value=3)

# 逐元素相加
result_add = paddle.add(x, y)
print(result_add)  # 输出: Tensor(shape=[2, 2], dtype=int32, place=CUDAPlace(0), stop_gradient=True, value=[[5, 5], [5, 5]])

# 判断两个Tensor的全部元素是否相等
result_equal_all = x.equal_all(y)
print(result_equal_all)  # 输出: Tensor(shape=[1], dtype=bool, place=CUDAPlace(0), stop_gradient=True, value=[False])
</code></pre>
<h2 id="数据集定义与加载"><a href="#数据集定义与加载" class="headerlink" title="数据集定义与加载"></a>数据集定义与加载</h2><h3 id="1、定义数据集"><a href="#1、定义数据集" class="headerlink" title="1、定义数据集"></a>1、定义数据集</h3><p>在PaddlePaddle中定义数据集通常有两种方式：直接加载内置数据集和自定义数据集。</p>
<h4 id="1-1-直接加载内置数据集"><a href="#1-1-直接加载内置数据集" class="headerlink" title="1.1 直接加载内置数据集"></a>1.1 直接加载内置数据集</h4><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=飞桨&amp;spm=1001.2101.3001.7020">飞桨</a>框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/vision/Overview_cn.html#api">paddle.vision.datasets</a> 和 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh//api/paddle/text/Overview_cn.html#api">paddle.text</a> 目录下内置了一些经典数据集可直接调用.</p>
<p>PaddlePaddle提供了内置数据集，你可以直接调用这些数据集。举例来说，以MNIST数据集为例，你可以这样加载内置数据集：</p>
<pre><code class="lang-python">from paddle.vision.datasets import MNIST
from paddle.vision.transforms import Normalize

transform = Normalize(mean=[127.5], std=[127.5], data_format=&#39;CHW&#39;)
train_dataset = MNIST(mode=&#39;train&#39;, transform=transform)
test_dataset = MNIST(mode=&#39;test&#39;, transform=transform)

print(&#39;train images: &#39;, len(train_dataset), &#39;, test images: &#39;, len(test_dataset))
</code></pre>
<h4 id="1-2-使用paddle-io-Dataset自定义数据集"><a href="#1-2-使用paddle-io-Dataset自定义数据集" class="headerlink" title="1.2 使用paddle.io.Dataset自定义数据集"></a>1.2 使用<code>paddle.io.Dataset</code>自定义数据集</h4><p>如果你有自己的数据，可以通过继承<code>paddle.io.Dataset</code>类来实现自定义数据集。你需要完成以下步骤：</p>
<pre><code class="lang-python">import os
import cv2
import numpy as np
from paddle.io import Dataset
from paddle.vision.transforms import Normalize

class MyDataset(Dataset):
    def __init__(self, data_dir, label_path, transform=None):
        super().__init__()
        self.data_list = []
        with open(label_path, encoding=&#39;utf-8&#39;) as f:
            for line in f.readlines():
                image_path, label = line.strip().split(&#39;\t&#39;)
                image_path = os.path.join(data_dir, image_path)
                self.data_list.append([image_path, label])
        self.transform = transform

    def __getitem__(self, index):
        image_path, label = self.data_list[index]
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        image = image.astype(&#39;float32&#39;)
        if self.transform is not None:
            image = self.transform(image)
        label = int(label)
        return image, label

    def __len__(self):
        return len(self.data_list)

transform = Normalize(mean=[127.5], std=[127.5], data_format=&#39;CHW&#39;)

train_custom_dataset = MyDataset(&#39;mnist/train&#39;, &#39;mnist/train/label.txt&#39;, transform)
test_custom_dataset = MyDataset(&#39;mnist/val&#39;, &#39;mnist/val/label.txt&#39;, transform)

print(&#39;train_custom_dataset images: &#39;, len(train_custom_dataset), &#39;, test_custom_dataset images: &#39;, len(test_custom_dataset))
</code></pre>
<h3 id="2、迭代读取数据集"><a href="#2、迭代读取数据集" class="headerlink" title="2、迭代读取数据集"></a>2、迭代读取数据集</h3><p>在飞桨（PaddlePaddle）框架中，使用<code>paddle.io.DataLoader</code>来定义数据读取器是一种推荐的方式，它可以实现对数据集的多进程读取，同时自动进行批次划分的工作。下面我将详细解释您提供的代码示例中关于迭代处理数据的部分：</p>
<h3 id="2-1-使用paddle-io-DataLoader定义数据读取器"><a href="#2-1-使用paddle-io-DataLoader定义数据读取器" class="headerlink" title="2.1 使用paddle.io.DataLoader定义数据读取器"></a>2.1 使用<code>paddle.io.DataLoader</code>定义数据读取器</h3><p>在这个部分，您首先定义并初始化了一个数据读取器<code>train_loader</code>，用于加载训练数据集<code>train_custom_dataset</code>。在初始化数据读取器时，您设置了一些常用的字段：</p>
<ul>
<li><code>batch_size</code>：每批次读取的样本数，这里设置为64，表示每次读���64个样本。</li>
<li><code>shuffle</code>：指定是否打乱样本顺序，设置为True表示在取数据时打乱样本顺序，以降低过拟合风险。</li>
<li><code>drop_last</code>：是否丢弃不完整的批次样本，设置为True表示丢弃因数据集样本数不能被<code>batch_size</code>整除而产生的最后一个不完整的batch。</li>
<li><code>num_workers</code>：用于设置加载数据的子进程个数，设置为大于0时开启多进程异步加载数据，可提升数据读取速度。</li>
</ul>
<p>接着，您使用<code>enumerate(train_loader())</code>来迭代读取数据，<code>train_loader()</code>返回一个可迭代对象，每次迭代返回一个批次的数据。在循环内部，您将每个批次的数据解包成<code>images</code>和<code>labels</code>，然后打印出当前批次的<code>batch_id</code>、训练数据的形状和标签数据的形状。</p>
<pre><code class="lang-python">from paddle.io import DataLoader, Dataset  
import paddle  

# 假设 train_custom_dataset 已经被定义并实例化  
# train_custom_dataset = MyCustomDataset(...)  

# 使用 DataLoader 加载数据  
train_loader = paddle.io.DataLoader(  
    train_custom_dataset,  
    batch_size=64,  
    shuffle=True,  
    num_workers=1,  
    drop_last=True  
)  

# 迭代读取数据  
for batch_id, (images, labels) in enumerate(train_loader):  
    print(&quot;batch_id: &#123;&#125;, 训练数据shape: &#123;&#125;, 标签数据shape: &#123;&#125;&quot;.format(batch_id, images.shape, labels.shape))
</code></pre>
<h3 id="2-2-自定义采样器"><a href="#2-2-自定义采样器" class="headerlink" title="2.2 自定义采样器"></a>2.2 自定义采样器</h3><p>在飞桨框架中，提供了多种采样器来实现更灵活的数据加载方式。这里演示了几种不同的采样器的用法：</p>
<ul>
<li>批采样器<code>BatchSampler</code>：在示例中定义了一个批采样器<code>bs</code>，设置了采样数据集源、采样批大小、是否乱序等参数，然后将其传入<code>paddle.io.DataLoader</code>中的<code>batch_sampler</code>参数来获取采样数据。</li>
<li>顺序采样器<code>SequenceSampler</code>和随机采样器<code>RandomSampler</code>：展示了如何使用这两种采样器并打印采样结果。</li>
<li>分布式批采样器<code>DistributedBatchSampler</code>：用于分布式训练情况下的批量采样，示例中展示了分布式采样器的使用方法。</li>
</ul>
<pre><code class="lang-python">from paddle.io import Sampler  

class CustomSampler(Sampler):  
    def __init__(self, data_source, indices):  
        self.data_source = data_source  
        self.indices = indices  

    def __iter__(self):  
        return iter(self.indices)  

    def __len__(self):  
        return len(self.indices)  

# 假设 indices 是您自定义的索引列表  
indices = [i for i in range(len(train_custom_dataset))]  # 示例：简单地使用所有索引  

# 使用自定义采样器  
custom_sampler = CustomSampler(train_custom_dataset, indices)  
train_loader_with_custom_sampler = paddle.io.DataLoader(  
    train_custom_dataset,  
    batch_size=64,  
    sampler=custom_sampler,  
    num_workers=1  
)  

# 迭代读取数据（使用自定义采样器）  
for batch_id, (images, labels) in enumerate(train_loader_with_custom_sampler):  
    print(&quot;batch_id: &#123;&#125;, 训练数据shape: &#123;&#125;, 标签数据shape: &#123;&#125;&quot;.format(batch_id, images.shape, labels.shape))
</code></pre>
<h2 id="Transforms-数据预处"><a href="#Transforms-数据预处" class="headerlink" title="Transforms 数据预处"></a>Transforms 数据预处</h2><h3 id="1、paddle-vision-transforms-介绍"><a href="#1、paddle-vision-transforms-介绍" class="headerlink" title="1、paddle.vision.transforms 介绍"></a>1、paddle.vision.transforms 介绍</h3><p>飞桨框架在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/vision/Overview_cn.html#about-transforms">paddle.vision.transforms</a> 下内置了数十种图像数据处理方法，可以通过以下代码查看</p>
<pre><code class="lang-python">paddle.vision.transforms.__all__
</code></pre>
<p>在 PaddlePaddle 中，<code>paddle.vision.transforms</code> 模块提供了一系列用于图像处理和数据增强的转换函数，这些函数可以帮助您对数据进行预处理、增强和转换，以供神经网络训练或推断使用。下面是一些常用的转换函数：</p>
<p> [‘BaseTransform’, ‘Compose’, ‘Resize’, ‘RandomResizedCrop’, ‘CenterCrop’, ‘RandomHorizontalFlip’, ‘RandomVerticalFlip’, ‘Transpose’, ‘Normalize’, ‘BrightnessTransform’, ‘SaturationTransform’, ‘ContrastTransform’, ‘HueTransform’, ‘ColorJitter’, ‘RandomCrop’, ‘Pad’, ‘RandomRotation’, ‘Grayscale’, ‘ToTensor’, ‘to_tensor’, ‘hflip’, ‘vflip’, ‘resize’, ‘pad’, ‘rotate’, ‘to_grayscale’, ‘crop’, ‘center_crop’, ‘adjust_brightness’, ‘adjust_contrast’, ‘adjust_hue’, ‘normalize’]</p>
<ol>
<li><code>Compose</code>：将多个转换函数组合成一个序列，按顺序依次对数据进行转换。</li>
<li><code>RandomHorizontalFlip</code>：以一定的概率随机水平翻转输入图像，可用于数据增强。</li>
<li><code>RandomVerticalFlip</code>：以一定的概率随机垂直翻转输入图像，也是数据增强的一种方式。</li>
<li><code>Resize</code>：调整输入图像的大小，可以设置目标尺寸或调整比例。</li>
<li><code>RandomResizedCrop</code>：随机裁剪并调整大小，常用于数据增强和训练时的输入处理。</li>
<li><code>ColorJitter</code>：随机颜色抖动，用于增加数据多样性。</li>
<li><code>Normalize</code>：标准化图像数据，减去均值并除以标准差，通常用于输入数据预处理。</li>
</ol>
<p>这些转换函数可以按需组合使用，以实现对图像数据的预处理和增强。通过使用适当的转换函数，您可以提高训练模型的数据多样性、模型的泛化能力和性能。</p>
<p>要使用 PaddlePaddle 中的图像处理和数据增强的转换函数，通常需要按照以下步骤进行：</p>
<ol>
<li>导入必要的库和模块：</li>
</ol>
<pre><code class="lang-python">import paddle
from paddle.vision.transforms import Compose, RandomHorizontalFlip, Resize, Normalize
</code></pre>
<ol>
<li>创建转换函数序列（Compose）：</li>
</ol>
<pre><code class="lang-python">transform = Compose([
    RandomHorizontalFlip(),  # 随机水平翻转
    Resize(size=256),  # 调整大小为256x256
    Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # 标准化
])
</code></pre>
<ol>
<li>应用转换函数到数据集：<br>假设您有一个数据集 <code>dataset</code>，您可以按如下方式应用转换函数：</li>
</ol>
<pre><code class="lang-python">dataset_transformed = dataset.transform(transform)
</code></pre>
<ol>
<li>创建数据加载器（DataLoader）并迭代数据：<br>最后，您可以使用创建好的转换后的数据集来初始化 DataLoader，并迭代读取数据用于模型的训练或推断：</li>
</ol>
<pre><code class="lang-python">data_loader = paddle.io.DataLoader(dataset_transformed, batch_size=32, shuffle=True)
for data in data_loader:
    # 在这里处理每个批次的数据，例如输入模型进行训练
</code></pre>
<h3 id="2、在数据集中应用数据预处理操作"><a href="#2、在数据集中应用数据预处理操作" class="headerlink" title="2、在数据集中应用数据预处理操作"></a>2、在数据集中应用数据预处理操作</h3><ul>
<li><h4 id="在框架内置数据集中应用"><a href="#在框架内置数据集中应用" class="headerlink" title="在框架内置数据集中应用"></a>在框架内置数据集中应用</h4></li>
</ul>
<pre><code class="lang-python">train_dataset = paddle.vision.datasets.MNIST(mode=&#39;train&#39;, transform=transform)
</code></pre>
<ul>
<li><h4 id="在自定义的数据集中应用"><a href="#在自定义的数据集中应用" class="headerlink" title="在自定义的数据集中应用"></a>在自定义的数据集中应用</h4></li>
</ul>
<p>对于自定义的数据集，可以在数据集中将定义好的数据处理方法传入 <code>__init__</code> 函数，将其定义为自定义数据集类的一个属性，然后在 <code>__getitem__</code> 中将其应用到图像上，如下述代码所示：</p>
<pre><code class="lang-python">import os
import cv2
import numpy as np
from paddle.io import Dataset
class MyDataset(Dataset):
    &quot;&quot;&quot;
    步骤一：继承 paddle.io.Dataset 类
    &quot;&quot;&quot;
    def __init__(self, data_dir, label_path, transform=None):
        &quot;&quot;&quot;
        步骤二：实现 __init__ 函数，初始化数据集，将样本和标签映射到列表中
        &quot;&quot;&quot;
        super().__init__()
        self.data_list = []
        with open(label_path,encoding=&#39;utf-8&#39;) as f:
            for line in f.readlines():
                image_path, label = line.strip().split(&#39;\t&#39;)
                image_path = os.path.join(data_dir, image_path)
                self.data_list.append([image_path, label])
        # 2. 传入定义好的数据处理方法，作为自定义数据集类的一个属性
        self.transform = transform
    def __getitem__(self, index):
        &quot;&quot;&quot;
        步骤三：实现 __getitem__ 函数，定义指定 index 时如何获取数据，并返回单条数据（样本数据、对应的标签）
        &quot;&quot;&quot;
        image_path, label = self.data_list[index]
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        image = image.astype(&#39;float32&#39;)

        # 3. 应用数据处理方法到图像上
        if self.transform is not None:
            image = self.transform(image)
        label = int(label)
        return image, label

    def __len__(self):
        &quot;&quot;&quot;
        步骤四：实现 __len__ 函数，返回数据集的样本总数
        &quot;&quot;&quot;
        return len(self.data_list)

# 1. 定义随机旋转和改变图片大小的数据处理方法
transform = Compose([RandomRotation(10), Resize(size=32)])

custom_dataset = MyDataset(&#39;mnist/train&#39;,&#39;mnist/train/label.txt&#39;, transform)
</code></pre>
<h2 id="模型组网"><a href="#模型组网" class="headerlink" title="模型组网"></a>模型组网</h2><p>本节介绍了如何在飞桨框架中使用内置的LeNet模型以及Paddle.nn模块的不同方式构建神经网络，包括Sequential方式和SubclassLayer方式，以满足不同复杂度的网络需求。</p>
<h3 id="1、直接使用内置模型"><a href="#1、直接使用内置模型" class="headerlink" title="1、直接使用内置模型"></a>1、直接使用内置模型</h3><p>飞桨框架目前在 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/vision/Overview_cn.html#about-models">paddle.vision.models</a> 下内置了<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=计算机视觉领域&amp;spm=1001.2101.3001.7020">计算机视觉领域</a>的一些经典模型，只需一行代码即可完成网络构建和初始化，适合完成一些简单的深度学习任务，满足深度学习初阶用户感受模型的输入和输出形式、了解模型的性能。</p>
<pre><code class="lang-python">paddle.vision.models.__all__
</code></pre>
<p> 以 LeNet 模型为例，可通过如下代码组网：</p>
<pre><code class="lang-python"># 模型组网并初始化网络
lenet = paddle.vision.models.LeNet(num_classes=10)
# 可视化模型组网结构和参数
paddle.summary(lenet,(1, 1, 28, 28))
</code></pre>
<pre><code class="lang-bash">---------------------------------------------------------------------------
 Layer (type)       Input Shape          Output Shape         Param #    
===========================================================================
   Conv2D-1       [[1, 1, 28, 28]]      [1, 6, 28, 28]          60       
    ReLU-1        [[1, 6, 28, 28]]      [1, 6, 28, 28]           0       
  MaxPool2D-1     [[1, 6, 28, 28]]      [1, 6, 14, 14]           0       
   Conv2D-2       [[1, 6, 14, 14]]     [1, 16, 10, 10]         2,416     
    ReLU-2       [[1, 16, 10, 10]]     [1, 16, 10, 10]           0       
  MaxPool2D-2    [[1, 16, 10, 10]]      [1, 16, 5, 5]            0       
   Linear-1          [[1, 400]]            [1, 120]           48,120     
   Linear-2          [[1, 120]]            [1, 84]            10,164     
   Linear-3          [[1, 84]]             [1, 10]              850      
===========================================================================
Total params: 61,610
Trainable params: 61,610
Non-trainable params: 0
---------------------------------------------------------------------------
Input size (MB): 0.00
Forward/backward pass size (MB): 0.11
Params size (MB): 0.24
Estimated Total Size (MB): 0.35
---------------------------------------------------------------------------


&#123;&#39;total_params&#39;: 61610, &#39;trainable_params&#39;: 61610&#125;
</code></pre>
<h3 id="2、Paddle-nn"><a href="#2、Paddle-nn" class="headerlink" title="2、Paddle.nn"></a>2、Paddle.nn</h3><ul>
<li><strong>使用 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Sequential_cn.html#sequential">paddle.nn.Sequential</a> 组网</strong>：构建顺序的线性网络结构（如 LeNet、AlexNet 和 VGG）时，可以选择该方式。相比于 Layer 方式 ，Sequential 方式可以用更少的代码完成线性网络的构建。</li>
</ul>
<pre><code class="lang-python">from paddle import nn
# 使用 paddle.nn.Sequential 构建 LeNet 模型
lenet_Sequential = nn.Sequential(
    nn.Conv2D(1, 6, 3, stride=1, padding=1),
    nn.ReLU(),
    nn.MaxPool2D(2, 2),
    nn.Conv2D(6, 16, 5, stride=1, padding=0),
    nn.ReLU(),
    nn.MaxPool2D(2, 2),
    nn.Flatten(),
    nn.Linear(400, 120),
    nn.Linear(120, 84), 
    nn.Linear(84, 10)
)

# 可视化模型组网结构和参数
paddle.summary(lenet_Sequential,(1, 1, 28, 28))
</code></pre>
<ul>
<li><strong>使用 <a target="_blank" rel="noopener" href="https://www.paddlepaddle.org.cn/documentation/docs/zh/api/paddle/nn/Layer_cn.html#layer">paddle.nn.Layer</a> 组网（推荐）</strong>：构建一些比较复杂的网络结构时，可以选择该方式。相比于 Sequential 方式，Layer 方式可以更灵活地组建各种网络结构。Sequential 方式搭建的网络也可以作为子网加入 Layer 方式的组网中。</li>
</ul>
<p>构建一些比较复杂的网络结构时，可以选择该方式，组网包括三个步骤：</p>
<ol>
<li>创建一个继承自 <code>paddle.nn.Layer</code>的类；</li>
<li>在类的构造函数 <code>__init__</code> 中定义组网用到的神经网络层（layer）；</li>
<li>在类的前向计算函数 <code>forward</code> 中使用定义好的 layer 执行前向计算。</li>
</ol>
<p>仍然以 LeNet 模型为例，使用 paddle.nn.Layer 组网的代码如下：</p>
<pre><code class="lang-python"># 使用 Subclass 方式构建 LeNet 模型

class LeNet(nn.Layer):
    def __init__(self, num_classes=10):
        super().__init__()
        self.num_classes = num_classes
        # 构建 features 子网，用于对输入图像进行特征提取
        self.features = nn.Sequential(
            nn.Conv2D(1, 6, 3, stride=1, padding=1),
            nn.ReLU(),
            nn.MaxPool2D(2, 2),
            nn.Conv2D(6, 16, 5, stride=1, padding=0),
            nn.ReLU(),
            nn.MaxPool2D(2, 2))
        # 构建 linear 子网，用于分类

        if num_classes &gt; 0:
            self.linear = nn.Sequential(
                nn.Linear(400, 120),
                nn.Linear(120, 84), 
                nn.Linear(84, num_classes)
            )

    # 执行前向计算
    def forward(self, inputs):
        x = self.features(inputs)
        if self.num_classes &gt; 0:
            x = paddle.flatten(x, 1)
            x = self.linear(x)
        return x 

lenet_SubClass = LeNet()
# 可视化模型组网结构和参数
params_info = paddle.summary(lenet_SubClass,(1, 1, 28, 28))
print(params_info)
</code></pre>

    </div>
    
    
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Aircraft
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Aircraft
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    
<script
    src="https://giscus.app/client.js"
    data-repo="Aircraft-carrier/git-discussions-"
    data-repo-id="R_kgDOMSMEYQ"
    data-category="Announcements"
    data-category-id="DIC_kwDOMSMEYc4CglYu"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light_tritanopia"
    data-lang="zh-CN"
    crossorigin
    async
></script>









    

    <canvas
        id="fireworks"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
    ></canvas>
    <script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="/js/fireworks.min.js"></script>  

    <canvas
        id="background"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
    ></canvas>
    <script src="/js/background.min.js"></script>

    <div id="cursor"></div>
    <link rel="stylesheet" href="/css/cursor.min.css" />
    <script src="/js/cursor.min.js"></script>

</body>
</html>
